We present two statically schedulable constructs for computing over graphs rather than traditional ASTs: first-class references (Section~\ref{sec:dynamic}), enabling non-local edges to be dynamically computed, and an extension to an AST schema specification to accept non-local edges as part of the AST input (Section~\ref{sec:staticgags}), so the input is really an abstract syntax graph. We find 2 further expressive extensions should be coupled with first-class references: nested references (Section~\ref{sec:dynamic}) and first-class collections (Section~\ref{sec:collections}). Finally, we examine convenient encodings that use our extenions  (e.g., binding a node type as a shared child of multiple node types) and compare the expressive differences between our extensions.

Key to our approach is that we reuse an existing AG scheduler by rewriting an extended grammar into a traditional grammar. We rewrite many operations into  functions that are opaque to the scheduler. The scheduler is notified of the dependencies through function arguments but it is the code generator that must be modified (e.g., reconstituting a loop nest from a sequence of special loop function calls). Some of the rewrites should introduce dependencies to be analyzed by the scheduler but not emit any instructions during code generation; we introduce a \code{phantom} type modifier for such terms.

We briefly provide intuition for the transformations for each section:

\begin{enumerate}

\item \textbf{Non-nested First-Class References (Section~\ref{sec:dynamic}):} First-class references are useful for tasks such as dynamically computing the association of every cell in a table with both a column and row. We model passing a reference to a node as passing the related set of attributes. A basic type analysis reveals the necessary information to expand each term.

To guarantee a non-locally referenced attribute is not repeatedly assigned, we check that non-local attributes to be read-only, though this might actually be relaxed. Generated code should use references (e.g., C++ pointers) rather than passing individual attributes; reference manipulations are rewritten as pointer manipulation operators while the expansion to passing individual attributes is hidden using phantom types.

\item \textbf{Nested First-Class References (solved up to recursive types in Section~\ref{sec:nested}):} Nested references allow concise terms such as $Table \rightarrow Row \rightarrow Cell$. Without equivalent expressive support, such a chain of dereferences must be manually spread between several declarations for several nodes. We extend our approach used previously for non-nested references: passing a reference to a node should pass not only the nodes attributes but, recursively, also any attributes of nodes reachable from the node. To avoid the degenerate case of passing all attributes, we only want to pass attributes reachable from a node. We present a structural type inference based on constraints induced by manipulations of references (determined by a simpler nominal type inference). Passing a reference is rewritten to also pass phantom attributes under the the corresponding (partial) structural type. 

References with recursive structural types are particularly challenging.  \textbf{[[TODO: I'm finding handling nested types in this case difficult!]]} Na\"{i}ve expansion under our encoding will not terminate. We can still schedule such grammars by propagating attributes up to the cycle \text{[[maybe?]]}, but they are unsafe: under our simple inference scheme and grammar representation, we cannot guarantee that a dereferenced node exists. In some cases \text{[[maybe?]]}, we can ensure such references are terminating and defined by inferring additional grammar schema constraints.

\item \textbf{First-Class Collections of References (Section~\ref{sec:collections}):} For tasks like computing the association of cells with rows and columns in tables, we found it necessary to pass \emph{collections} of references rather just one. We introduce the ability to create collections through append and concatenate operations (or Kleene stars in the tree schema), allow them to be passed as first-class values, and support nestable loops over them. Collections are an expressive extension: a collection's size has no static bound, so we cannot statically allocate an attribute for every member. While collection attributes are generally read-only, in the case of a loop over a local production, we also support writing.

Our insight is that in-order loops over homogenous collections of nodes can be treated similarly to references. We schedule the union of (potentially nested) loop body statements; the scheduled sequence may break the original loop structure. E.g., a programmar might specify a single loop, but the loop body might be split in two: the first partition of statements occurs with a loop at the beginning of a node visit while the second partition occurs at the end. In the case of nested loops, not all uses may require all nestings; e.g., a thrice-nested loop might be scheduled as a thrice-nested in one tree traversal but only the outer loop in another tree traversal. Thus, after totally ordering loop body statements across and within tree traversals using a normal AG scheduler, our code generator reintroduces the nesting structure.

\item \textbf{Abstract Syntax Graphs (Section~\ref{sec:staticgags}):} A grammar might recieve a graph as input (rather than, in the case of first-class references, a tree and then dynamically computing edges). The dependency tracking used in our transformation for first-class references does not directly apply as there is no reference passing to rewrite as attribute passing. We use a conservative type-based extension to avoid this problem: a non-local attribute will not be scheduled for a read until after all instances of the attribute are guanteed to be scheduled. As with first-class references, these attributes are read-only.

\item \textbf{Node Binding. \textbf{[[haven't worked through, but the table spec look weird without something like this]]}} Our reference passing primitive is cumbersome to encode the common notion of a node with multiple parents. Without additional support, a conceptually shared node must be partitioned into 3 nodes (or more):
a shared node for attributes read by any parent, and for each parent, a node for the attributes the parent writes. Furthermore, as a shared node is likely written by multiple parents, the references to the various node instances must be propogated. In short, while first class references enable computing over graphs, they do not satisfyingly meet our goal of \emph{conveniently} computing over them. We introduce a new binding construct to automate the above encoding pattern. We consider it for both grammars where edges are dynamically computed and provided as input.
\item \textbf{Analysis. \textbf{[[haven't written this up yet]]}} We find several key properties. First, the dynamic grammars can schedule more programs than the static ones \textbf{[[I think]]}. Second, our static grammars side-step the need for collection extensions which were introduced soley to improve the ability to build new edges. Next, in both cases, our technique of reusing existing AG schedulers is impacted by the programmer's choice of minimum spanning tree to describe the grammar. For example, the choice in schema (MST of the graph) impacts which attributes may be written locally. Finally, we discuss possible analysis support for relaxing our restrictions on recursive types and writing non-local attributes.
\end{enumerate}
